# -*- coding: utf-8 -*-
"""PythonCourse4_timeseries.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10ZZAR4ZSBewY4_yVuPFqi8mluy719eSQ
"""

# Commented out IPython magic to ensure Python compatibility.
from dateutil.parser import parse
import matplotlib as mpl
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
plt.rcParams.update({'figure.figsize': (10, 7), 'figure.dpi': 120})

# %matplotlib inline

"""# Time series"""

df = pd.DataFrame(np.random.randn(70, 4),
      index = pd.date_range('1/12/2020', periods=70),
      columns = ['A', 'B','C','D'])
df['big'] = 0
df.loc[df['A'] > 0.9, 'big'] = 1 #set some 'big' numbers class
df = df.reset_index()

"""## time in Pandas"""

ts = df.copy()

ts

ts.dtypes

ts['date'] = pd.to_datetime(ts['index'])
ts

ts.date[2] #look at cell#2

type(ts.date[2])

pd.to_datetime('1991-09-01')

s1 = pd.to_datetime(['2/5-10'], format='%d/%m-%y')

s1

s2 = pd.to_datetime(['2/5-10'], format='%m/%d-%y')

s2

dtime.month, dtime.day, dtime.year

"""### timedelta"""

s = pd.Series(pd.date_range('2012-1-1', periods=3, freq='D'))
td = pd.Series([ pd.Timedelta(days=i) for i in range(3) ])
df = pd.DataFrame(dict(A = s, B = td))
df

df.B[2] #timedelta

df.B[2]+s2 #add timedelta to date

between_days = s2-s1 #operations with dates
between_days, s2, s1

df.A.shift(-1) # produces NaT (time NaN)

df.A + pd.DateOffset(days=1) # clean, no NaN

"""## time in Python: datetime"""

from datetime import datetime, timedelta

d = datetime.today() + timedelta(hours=6, minutes=50)
d.strftime('%H:%M %p')

"""### back to time series column in Pandas"""

ts

ts.dtypes

ts.set_index('date')

ts # not saved!

ts.set_index('date', inplace=True) #now MAYBE saved; >ts = ts.set_index('date') # saved for sure!

ts

data_daily = ts

data_daily

data_daily.index.day_name() #extract info

ts['now_date'] = ts.index #inheritage of a type

ts.dtypes

ts.now_date[3].day_name()

"""### why indexing"""

ts.loc['2020-03'] # find the date

ts[ts.index.isin(pd.date_range("2020-01-11", "2020-02-07"))] #many filtering possibilities

"""### plot time series"""

ts.plot(x = 'now_date', y='A')
plt.show()

"""# Time series analysis"""

#Australian Drug Sales data, free available dataset
df = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/a10.csv', parse_dates=['date'])
df.head()

df.dtypes

def plot_df(df, x, y, title="", xlabel='Date', ylabel='Value', dpi=100):
    plt.figure(figsize=(16,5), dpi=dpi)
    plt.plot(x, y, color='tab:red')
    plt.gca().set(title=title, xlabel=xlabel, ylabel=ylabel)
    plt.show()

plot_df(df, x=df.date, y=df.value, title='Monthly anti-diabetic drug sales in Australia from 1992 to 2008.')

"""### Seasonality"""

# Prepare data
df['year'] = [d.year for d in df.date]
df['month'] = [d.strftime('%b') for d in df.date]
years = df['year'].unique()

# Prep Colors
np.random.seed(100)
mycolors = np.random.choice(list(mpl.colors.XKCD_COLORS.keys()), len(years), replace=False)

# Draw Plot
plt.figure(figsize=(16,12), dpi= 80)
for i, y in enumerate(years):
    if i > 0:
        plt.plot('month', 'value', data=df.loc[df.year==y, :], color=mycolors[i], label=y)
        plt.text(df.loc[df.year==y, :].shape[0]-.9, df.loc[df.year==y, 'value'][-1:].values[0], y, fontsize=12, color=mycolors[i])

# Decoration
plt.gca().set(xlim=(-0.3, 11), ylim=(2, 30), ylabel='$Drug Sales$', xlabel='$Month$')
plt.yticks(fontsize=12, alpha=.7)
plt.title("Seasonal Plot of Drug Sales Time Series", fontsize=20)
plt.show()

"""### Boxplot of Month-wise (Seasonal) and Year-wise (trend) Distribution"""

# Prepare data
df['year'] = [d.year for d in df.date]
df['month'] = [d.strftime('%b') for d in df.date]
years = df['year'].unique()

# Draw Plot
fig, axes = plt.subplots(1, 2, figsize=(20,7), dpi= 80)
sns.boxplot(x='year', y='value', data=df, ax=axes[0])
sns.boxplot(x='month', y='value', data=df.loc[~df.year.isin([1991, 2008]), :])

# Set Title
axes[0].set_title('Year-wise Box Plot\n(The Trend)', fontsize=18);
axes[1].set_title('Month-wise Box Plot\n(The Seasonality)', fontsize=18)
plt.show()

"""### Any time series may be split into the following components: Base Level + Trend + Seasonality + Error"""

from statsmodels.tsa.seasonal import seasonal_decompose
from dateutil.parser import parse

df

df = df.set_index('date')

"""### Multiplicative Time Series:
### Value = Base Level x Trend x Seasonality x Error
"""

# Multiplicative Decomposition
result_mul = seasonal_decompose(df['value'], model='multiplicative', extrapolate_trend='freq')

# Plot
plt.rcParams.update({'figure.figsize': (15,10)})
result_mul.plot()
plt.show()

"""### Additive time series:
### Value = Base Level + Trend + Seasonality + Error
"""

# Additive Decomposition
result_add = seasonal_decompose(df['value'], model='additive', extrapolate_trend='freq')

# Plot
plt.rcParams.update({'figure.figsize': (15,10)})
result_add.plot()
plt.show()

# Extract the Components ----
# Actual Values = Product of (Seasonal * Trend * Resid)
df_reconstructed = pd.concat([result_mul.seasonal, result_mul.trend, result_mul.resid, result_mul.observed], axis=1)
df_reconstructed.columns = ['season', 'trend', 'resid', 'actual']
df_reconstructed.head()

"""### Stationarity of a time series.
#### A stationary series is one where the values of the series is not a function of time.

#### Forecasting a stationary series is relatively easy and the forecasts are more reliable.
#### The statistical properties of the series like mean, variance and autocorrelation are constant over time.
#### Autocorrelation of the series is the correlation of the series with its previous values.

### Check the stationarity
#### ADF test, where assumed that the time series possesses is non-stationary if the P-Value is greater than the significance level

#### KPSS test, where assumed that the time series possesses is stationary and the P-Value interpretation is just the opposite of ADH test
"""

from statsmodels.tsa.stattools import adfuller, kpss

# ADF Test
result = adfuller(df.value.values, autolag='AIC')
print(f'p-value: {result[1]}')
for key, value in result[4].items():
    print('Critial Values:')
    print(f'   {key}, {value}')

# KPSS Test
result = kpss(df.value.values, regression='c')
print('p-value: %f' % result[1])
for key, value in result[3].items():
    print('Critial Values:')
    print(f'   {key}, {value}')

"""## Detrending a time series is to remove the trend component from a time series."""

# Using scipy: Subtract the line of best fit
# (The line of best fit may be obtained from a linear regression model with the time steps as the predictor.)

from scipy import signal
detrended = signal.detrend(df.value.values)
plt.plot(detrended)

# Using statmodels: Subtracting the Trend Component.
from statsmodels.tsa.seasonal import seasonal_decompose
result_mul = seasonal_decompose(df['value'], model='multiplicative', extrapolate_trend='freq')
detrended = df.value.values - result_mul.trend
plt.plot(detrended)

"""## Test for seasonality of a time series"""

# use the Autocorrelation Function (ACF) plot
from pandas.plotting import autocorrelation_plot

# Draw Plot
plt.rcParams.update({'figure.figsize':(9,5), 'figure.dpi':120})
autocorrelation_plot(df.value.tolist())

"""## Deseasonalize a time series:

### Take a moving average with length as the seasonal window. This will smoothen in series in the process.

### Seasonal difference the series (subtract the value of previous season from the current value)

### Divide the series by the seasonal index obtained from STL decomposition
"""

# Subtracting the Trend Component.

# Time Series Decomposition
result_mul = seasonal_decompose(df['value'], model='multiplicative', extrapolate_trend='freq')

# Deseasonalize
deseasonalized = df.value.values / result_mul.seasonal

# Plot
plt.plot(deseasonalized)
plt.plot()

